---
title: "PPCA0026 - Tarefa 5: Métodos de Monte Carlo e MCMC"
subtitle: "Baseado em 'Statistical Computing with R' de Maria Rizzo"
author: "Sílvio Ferreira Gomes Júnior"
date: "2025-08-08"
format:
  html:
    embed-resources: true
    toc: true
    toc-depth: 3
    theme: cosmo
    code-fold: show
    code-tools: true
---

## Introdução

Este arquivo serve como seu template de resposta. Preencha as seções marcadas com seu código R, as saídas geradas, e suas análises textuais.

```{r setup, include=FALSE}
# Carregue todos os pacotes que você usará aqui
library(tidyverse)
library(mvtnorm) # Pode ser útil para o Problema 3
```

---

## Problema 1: Integração por Monte Carlo e Variáveis Antitéticas (Capítulo 7)

Neste problema, vamos estimar o valor de uma integral definida e ver como uma técnica de amostragem mais inteligente pode melhorar a precisão da nossa estimativa.

**Tarefa (baseada no Exercício 7.5 de Rizzo):**

O nosso objetivo é estimar o valor de $I = \int_0^1 \frac{e^{-x}}{1+x^2} dx$.



### 1.1 Estimação com Monte Carlo Padrão

```{r prob1a_standard_mc}
# Defina a função a ser integrada
f <- function(x) {
  # ... seu código aqui ...
  exp(-x) / (1 + x^2)
}

m <- 10000 # Número de amostras
set.seed(123)

# Gere as amostras e calcule a estimativa
x <- runif(m)
fx <- f(x)
mc_estimate <- mean(fx)
mc_var <- var(fx)

# Reporte a estimativa e a variância empírica


cat("A estimativa da integral é: ", round(mc_estimate, 2), "\n")
cat("A estimativa para a variância empírica é: $", round(mc_var , 2), "\n")

# ...
```

### 1.2 Estimação com Variáveis Antitéticas

```{r prob1b_antithetic_mc}
# Use m/2 amostras para criar m pontos de avaliação
set.seed(123)

m2 <- m / 2
u <- runif(m2)


# Gere as amostras e calcule a estimativa antitética
amostra_antietica <- (f(u) + f(1 - u)) / 2
estimativa_antietica <- mean(amostra_antietica)
variancia_antietica <- var(amostra_antietica) 

# Reporte a estimativa e a variância empírica
cat("A estimativa da integral (antitética) é: ", round(estimativa_antietica, 4), "\n")
cat("A estimativa para a variância empírica (antitética) é: ", round(variancia_antietica, 6), "\n")

```

### 1.3 Análise e Comparação

*SUA ANÁLISE AQUI:* Apresente uma tabela comparando os resultados (valor estimado e variância) dos dois métodos. Em que percentual a técnica de variáveis antitéticas reduziu a variância da estimativa em comparação com o método de Monte Carlo padrão?

| Método                        | Estimativa da Integral | Variância Empírica |
|-------------------------------|------------------------|--------------------|
| Monte Carlo Padrão            |0,53|0,06|
| Método da estimativa Antitética   |0,52|0,001|

**Redução percentual da variância:** A redução foi de, aproximadamente, 98%

---

## Problema 2: Amostragem por Rejeição (Rejection Sampling) (Capítulo 6)

O objetivo é gerar amostras de uma distribuição `Beta(2, 2)` usando o algoritmo de amostragem por rejeição.

### 2.1 Encontrando a Constante `c`

```{r prob2a_find_c}
#Este problema introduz a lógica de aceitar/rejeitar amostras, que é fundamental para o MCMC. 
#O objetivo é gerar amostras de uma distribuição alvo usando uma distribuição “envelope” mais simples.

# A distribuição alvo é f(x) = dbeta(x, 2, 2)
# A distribuição envelope é g(x) = dunif(x, 0, 1) = 1
# Encontre o valor máximo da razão f(x)/g(x) no intervalo [0, 1].
# Você pode fazer isso analiticamente ou numericamente.

# Definindo a distribuição alvo:
f <- function(x) dbeta(x, 2, 2)
# Definindo a distribuição envelope
g <- function(x) dunif(x, 0, 1) 

# Encontrando o valor máximo de f(x)/g(x) no intervalo [0, 1]

grid <- seq(0, 1, length.out = 10001)
divisao <- f(grid) / g(grid)
c <- max(divisao)

cat("A estimativa de C é: ", round(c, 4), "\n")

```

**Análise da Tarefa 2.1:**

Após definir as duas funções de densidade, conforme solicitado, utilizei a dica de maximização da divisão de $\frac{f(x)}{g(x)}$. Enfim, apliquei essa função de divisão a um grid de valores entre 0 e 1 (10001)

### 2.2 Implementando o Amostrador por Rejeição

```{r prob2b_rejection_sampler}
# Escreva uma função que implementa o algoritmo de amostragem por rejeição.
# A função deve aceitar n (o número de amostras a gerar) e c como argumentos.
rejection_sampler_beta <- function(n, c) {

  # Definindo a distribuição alvo:
  f <- function(x) dbeta(x, 2, 2)
  # Definindo a distribuição envelope
  g <- function(x) dunif(x, 0, 1) 

  amostras_aceitas <- numeric(n)
  total_propostas <- 0
  aceitas <- 0
  
  # Loop até obter n amostras aceitas
  while(aceitas < n) {
    y <- runif(1, 0, 1) 
    u <- runif(1, 0, 1)
    
    #Tirei essa regra do livro
    if (u < f(y) / (c * g(y))) {
      aceitas <- aceitas + 1
      amostras_aceitas[aceitas] <- y
    }

    total_propostas <- total_propostas + 1
  }
  
  # Calcular taxa de aceitação
  taxa_aceitacao <- aceitas / total_propostas
  
  # Retornar lista com amostras e informações do processo
  return(list(
    amostras = amostras_aceitas,
    taxa_aceitacao = taxa_aceitacao,
    total_propostas = total_propostas
  ))
}

# Gere 2000 amostras usando sua função
set.seed(123)
resultado_beta <- rejection_sampler_beta(2000, 1.5)
amostras_beta <- resultado_beta$amostras

```


### 2.3 Verificação dos Resultados

```{r prob2c_verification}
# Crie um histograma das suas amostras geradas
# Sobreponha a curva de densidade teórica da Beta(2, 2) para verificar

# Organize as amostras em um data frame
df_beta <- data.frame(amostra = amostras_beta)

# Crie o histograma com ggplot2 e sobreponha a densidade teórica
ggplot(df_beta, aes(x = amostra)) +
  geom_histogram(aes(y = ..density..), bins = 30, fill = "lightblue", color = "white") +
  stat_function(fun = function(x) dbeta(x, 2, 2), color = "red", size = 1.2) +
  labs(title = "Amostragem por Rejeição: Beta(2,2)",
       x = "x", y = "Densidade") +
  theme_minimal() +
  theme(plot.title = element_text(hjust = 0.5)) +
  annotate("text", x = 0.8, y = 2.2, label = "Densidade Teórica Beta(2,2)", color = "red", size = 4)

# Reporte a taxa de aceitação do seu amostrador

cat("Taxa de aceitação:", round(resultado_beta$taxa_aceitacao, 4), "\n")
cat("Total de propostas:", resultado_beta$total_propostas, "\n")

```

**Análise da Tarefa 2.3:**

Uma taxa de aceitação de aproximadamente 0,66 significa que, em média, aproximadamente 2 em cada 3 amostras propostas pelo algoritmo foram aceitas para fazer parte do nosso conjunto final de possíveis valores. Como, de acordo com o livro citado, a taxa de aceitação teórica máxima é de $\frac{1}{c}$, então 1/1.5 = 0,666, ou seja, nossa taxa chegou ao limite.

---

## Problema 3: O Algoritmo de Metropolis-Hastings (Capítulo 9)

O objetivo é gerar amostras de uma distribuição Normal Bivariada com alta correlação ($\rho=0.9$) usando um amostrador de Metropolis-Hastings de passeio aleatório.

### 3.1 Implementando o Amostrador

```{r prob3a_metropolis_hastings}
# Defina a densidade alvo (ou seu logaritmo)
# A média é (0, 0) e a matriz de covariância tem 1s na diagonal e 0.9 fora dela.
# A função `mvtnorm::dmvnorm` pode ser útil para calcular a densidade.

# Implemente a função do amostrador de Metropolis-Hastings
metropolis_bvn <- function(n_iter, sigma_prop) {
  # n_iter: número de iterações
  # sigma_prop: desvio padrão da proposta (assumido igual para ambas as dimensões)
  
  # ... seu código aqui ...
  # Lembre-se de:
  # 1. Inicializar a cadeia.
  # 2. Loop pelas iterações.
  # 3. Propor um novo ponto.
  # 4. Calcular a razão de aceitação.
  # 5. Aceitar ou rejeitar.
  # 6. Armazenar o ponto na cadeia.
  # 7. Contar as aceitações.
}

# Execute o amostrador
# cadeia_mcmc <- metropolis_bvn(...)
```

### 3.2 Análise da Saída

```{r prob3b_analysis}
# Descarte o burn-in
# burn_in <- 2000
# cadeia_final <- ...

# Crie os trace plots para cada uma das duas variáveis
# ... seu código ggplot2 aqui ...

# Crie o scatter plot das amostras geradas
# ... seu código ggplot2 aqui ...

# Verificação Visual: Sobreponha as linhas de contorno teóricas
# ...

# Reporte a taxa de aceitação
# ...
```

**Análise da Tarefa 3.2:**

*INCLUA SEUS GRÁFICOS AQUI.* Os trace plots indicam que a cadeia convergiu? O scatter plot e as linhas de contorno mostram que seu amostrador explorou a distribuição alvo corretamente? Comente sobre o efeito de diferentes valores para a variância da proposta (`sigma_prop`) na taxa de aceitação e na eficiência do amostrador.
